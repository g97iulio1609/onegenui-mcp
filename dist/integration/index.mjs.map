{"version":3,"sources":["../../src/integration/ai-sdk.ts","../../src/integration/prompt.ts"],"sourcesContent":["import type { McpToolWireFormat, ScoredTool } from \"../types\";\nimport type { McpRegistry } from \"../registry\";\nimport type { McpConnectionManager } from \"../client/connection\";\nimport { tool, jsonSchema, type ToolSet, type JSONSchema7 } from \"ai\";\n\n// =============================================================================\n// AI SDK Integration\n// =============================================================================\n\nconst DEBUG = process.env.NODE_ENV === \"development\";\nconst DEFAULT_TOOL_TIMEOUT_MS = 45000;\nconst MIN_TOOL_TIMEOUT_MS = 5000;\nconst MAX_TOOL_TIMEOUT_MS = 300000;\n\nfunction normalizeTimeout(timeoutMs: unknown): number {\n  if (typeof timeoutMs !== \"number\" || !Number.isFinite(timeoutMs)) {\n    return DEFAULT_TOOL_TIMEOUT_MS;\n  }\n  return Math.min(MAX_TOOL_TIMEOUT_MS, Math.max(MIN_TOOL_TIMEOUT_MS, timeoutMs));\n}\n\nfunction withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutMessage: string,\n): Promise<T> {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  return new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => reject(new Error(timeoutMessage)), timeoutMs);\n\n    promise.then(\n      (value) => {\n        if (timeoutId) clearTimeout(timeoutId);\n        resolve(value);\n      },\n      (error) => {\n        if (timeoutId) clearTimeout(timeoutId);\n        reject(error);\n      },\n    );\n  });\n}\n\n/**\n * Tool execution context.\n */\nexport interface ToolExecutionContext {\n  /** Server ID the tool belongs to */\n  serverId: string;\n  /** Tool name */\n  toolName: string;\n}\n\n/**\n * Convert MCP JSON Schema to AI SDK compatible schema using jsonSchema() wrapper.\n */\nfunction convertToAiSdkSchema(mcpSchema: Record<string, unknown>) {\n  // The jsonSchema() helper wraps a JSON Schema for AI SDK compatibility\n  return jsonSchema(mcpSchema as JSONSchema7);\n}\n\n/**\n * Create a single AI SDK tool from an MCP tool definition.\n */\nfunction createAiSdkTool(\n  mcpTool: McpToolWireFormat,\n  serverId: string,\n  connectionManager: McpConnectionManager,\n) {\n  const toolName = mcpTool.name;\n\n  return tool({\n    description: mcpTool.description ?? \"\",\n    inputSchema: convertToAiSdkSchema(\n      (mcpTool.inputSchema as Record<string, unknown>) ?? { type: \"object\" },\n    ),\n    execute: async (args) => {\n      if (DEBUG) console.log(`[MCP Tool] Calling: ${toolName}`, args);\n\n      try {\n        // Get client (connects if needed)\n        const client = await connectionManager.getClient(serverId);\n        const timeoutMs = normalizeTimeout(client.config.timeout);\n\n        // Call the tool\n        const result = await withTimeout(\n          client.callTool(toolName, args as Record<string, unknown>, {\n            timeoutMs,\n          }),\n          timeoutMs,\n          `MCP tool '${toolName}' timed out after ${timeoutMs}ms`,\n        );\n\n        // Return structured content if available\n        if (result.structuredContent !== undefined) {\n          return result.structuredContent;\n        }\n\n        // Concatenate text content\n        const textContent = result.content\n          .filter((c) => c.type === \"text\")\n          .map((c) => (c as { type: \"text\"; text: string }).text)\n          .join(\"\\n\");\n\n        // Try to parse as JSON for better model consumption\n        if (textContent) {\n          try {\n            return JSON.parse(textContent);\n          } catch {\n            // Not valid JSON, return as-is\n            return textContent;\n          }\n        }\n\n        return result;\n      } catch (error) {\n        console.error(`[MCP Tool] Error calling ${toolName}:`, error);\n        throw error;\n      }\n    },\n  });\n}\n\n/**\n * Create an AI SDK toolset from selected MCP tools.\n *\n * This converts MCP tools to AI SDK v6 tool() format.\n * Each tool is wrapped with execution logic that calls the MCP server.\n *\n * @example\n * ```ts\n * import { streamText } from 'ai';\n * import { createToolsetFromMcp } from '@onegenui/mcp/integration';\n *\n * const toolset = await createToolsetFromMcp(\n *   connectionManager,\n *   selectedTools\n * );\n *\n * const result = await streamText({\n *   model: openai('gpt-4o'),\n *   tools: toolset,\n *   messages: [...],\n * });\n * ```\n */\nexport async function createToolsetFromMcp(\n  connectionManager: McpConnectionManager,\n  selectedTools: ScoredTool[],\n): Promise<ToolSet> {\n  const toolset: ToolSet = {};\n\n  for (const { tool: mcpTool, serverId } of selectedTools) {\n    toolset[mcpTool.name] = createAiSdkTool(\n      mcpTool,\n      serverId,\n      connectionManager,\n    );\n  }\n\n  return toolset;\n}\n\n/**\n * Create an AI SDK toolset from all registered MCP tools.\n * Use this when you want to expose all tools without selection.\n */\nexport async function createFullToolsetFromMcp(\n  registry: McpRegistry,\n  connectionManager: McpConnectionManager,\n): Promise<ToolSet> {\n  const toolset: ToolSet = {};\n  const states = registry.listServerStates();\n\n  const entries = Array.from(states.entries());\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    if (!entry) continue;\n    const [serverId, state] = entry;\n    if (state.config.enabled === false) continue;\n    if (!state.tools) continue;\n\n    for (const mcpTool of state.tools) {\n      toolset[mcpTool.name] = createAiSdkTool(\n        mcpTool,\n        serverId,\n        connectionManager,\n      );\n    }\n  }\n\n  return toolset;\n}\n\n/**\n * Options for loading MCP tools into AI SDK.\n */\nexport interface LoadMcpToolsOptions {\n  /** Registry instance */\n  registry: McpRegistry;\n  /** Connection manager instance */\n  connectionManager: McpConnectionManager;\n  /** Server IDs to include (optional, includes all if not specified) */\n  serverIds?: string[];\n  /** Connect to servers before returning tools */\n  connect?: boolean;\n}\n\n/**\n * Load MCP tools and return AI SDK compatible toolset.\n * This is a convenience function that handles connection.\n */\nexport async function loadMcpTools(\n  options: LoadMcpToolsOptions,\n): Promise<ToolSet> {\n  const { registry, connectionManager, serverIds, connect = true } = options;\n\n  const servers = registry.listServers();\n  const targetServers = serverIds\n    ? servers.filter((s) => serverIds.includes(s.id))\n    : servers.filter((s) => s.enabled !== false);\n\n  // Connect to servers if requested\n  if (connect) {\n    const connectPromises = targetServers.map((server) =>\n      connectionManager.getClient(server.id).catch((error) => {\n        console.error(`Failed to connect to ${server.id}:`, error);\n        return null;\n      }),\n    );\n    await Promise.all(connectPromises);\n  }\n\n  // Build toolset\n  return createFullToolsetFromMcp(registry, connectionManager);\n}\n","import type { McpToolWireFormat, ScoredTool, McpServerState } from \"../types\";\n\n// =============================================================================\n// Prompt Generation\n// =============================================================================\n\n/**\n * Generate a prompt section describing available MCP tools.\n *\n * This can be included in system prompts to help the LLM understand\n * what tools are available without using function calling.\n *\n * @example\n * ```ts\n * const toolsPrompt = generateMcpToolsPrompt(selectedTools);\n * const systemPrompt = `You are an AI assistant.\n *\n * ${toolsPrompt}\n *\n * Use tools when appropriate to help the user.`;\n * ```\n */\nexport function generateMcpToolsPrompt(\n  tools: ScoredTool[] | McpToolWireFormat[],\n): string {\n  if (tools.length === 0) {\n    return \"\";\n  }\n\n  const lines: string[] = [\n    \"## Available Tools\",\n    \"\",\n    \"You have access to the following tools:\",\n    \"\",\n  ];\n\n  for (const item of tools) {\n    const tool = \"tool\" in item ? item.tool : item;\n\n    lines.push(`### ${tool.name}`);\n    if (tool.description) {\n      lines.push(tool.description);\n    }\n\n    // Add parameter info\n    if (tool.inputSchema.properties) {\n      const props = tool.inputSchema.properties as Record<\n        string,\n        { type?: string; description?: string }\n      >;\n      const required = (tool.inputSchema.required as string[]) || [];\n\n      lines.push(\"\");\n      lines.push(\"**Parameters:**\");\n\n      for (const [name, schema] of Object.entries(props)) {\n        const isRequired = required.includes(name);\n        const typeStr = schema.type ?? \"any\";\n        const descStr = schema.description ? ` - ${schema.description}` : \"\";\n        const reqStr = isRequired ? \" (required)\" : \"\";\n        lines.push(`- \\`${name}\\`: ${typeStr}${reqStr}${descStr}`);\n      }\n    }\n\n    lines.push(\"\");\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Generate a compact tools summary for context-limited prompts.\n */\nexport function generateToolsSummary(\n  tools: ScoredTool[] | McpToolWireFormat[],\n): string {\n  if (tools.length === 0) {\n    return \"No tools available.\";\n  }\n\n  const toolNames = tools.map((item) => {\n    const tool = \"tool\" in item ? item.tool : item;\n    return tool.name;\n  });\n\n  return `Available tools: ${toolNames.join(\", \")}`;\n}\n\n/**\n * Generate a prompt section for tool results.\n */\nexport function generateToolResultPrompt(\n  toolName: string,\n  result: unknown,\n  isError = false,\n): string {\n  const prefix = isError ? \"Tool Error\" : \"Tool Result\";\n  const resultStr =\n    typeof result === \"string\" ? result : JSON.stringify(result, null, 2);\n\n  return `### ${prefix}: ${toolName}\\n\\n\\`\\`\\`\\n${resultStr}\\n\\`\\`\\``;\n}\n\n/**\n * Options for generating server status prompt.\n */\nexport interface ServerStatusPromptOptions {\n  /** Include tool counts */\n  includeToolCounts?: boolean;\n  /** Include connection status */\n  includeStatus?: boolean;\n  /** Include domains */\n  includeDomains?: boolean;\n}\n\n/**\n * Generate a prompt section describing MCP server status.\n */\nexport function generateServerStatusPrompt(\n  serverStates: Map<string, McpServerState> | Record<string, McpServerState>,\n  options: ServerStatusPromptOptions = {},\n): string {\n  const {\n    includeToolCounts = true,\n    includeStatus = true,\n    includeDomains = true,\n  } = options;\n\n  const lines: string[] = [\"## MCP Servers\", \"\"];\n\n  const entries =\n    serverStates instanceof Map\n      ? Array.from(serverStates.entries())\n      : Object.entries(serverStates);\n\n  for (const [id, state] of entries) {\n    const parts: string[] = [];\n\n    if (includeStatus) {\n      parts.push(`status: ${state.status}`);\n    }\n\n    if (includeDomains && state.config.domain) {\n      parts.push(`domain: ${state.config.domain}`);\n    }\n\n    if (includeToolCounts && state.metadata) {\n      parts.push(`tools: ${state.metadata.toolCount}`);\n    }\n\n    const name = state.config.name ?? id;\n    lines.push(`- **${name}** (${parts.join(\", \")})`);\n  }\n\n  return lines.join(\"\\n\");\n}\n"],"mappings":"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","names":["tool"]}