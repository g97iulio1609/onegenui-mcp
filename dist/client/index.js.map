{"version":3,"sources":["../../src/client/index.ts","../../src/registry/env-resolver.ts","../../src/client/local-client.ts","../../src/client/sdk-client.ts","../../src/security.ts","../../src/client/client.ts","../../src/client/connection.ts"],"sourcesContent":["// Client exports\nexport {\n  createMcpClient,\n  registerLocalModuleLoader,\n  type McpClient,\n} from \"./client\";\nexport {\n  createConnectionManager,\n  type McpConnectionManager,\n} from \"./connection\";\n","import type { McpServerConfig } from \"../types\";\n\n/**\n * Resolve environment variables in a string.\n * Supports ${VAR_NAME} syntax.\n */\nexport function resolveEnvVars(value: string): string {\n  return value.replace(/\\$\\{([^}]+)\\}/g, (_, varName) => {\n    return process.env[varName] ?? \"\";\n  });\n}\n\n/**\n * Resolve environment variables in server config.\n */\nexport function resolveServerEnv(config: McpServerConfig): McpServerConfig {\n  if (config.transport === \"stdio\") {\n    const resolvedEnv: Record<string, string> = {};\n\n    if (config.env) {\n      for (const [key, value] of Object.entries(config.env)) {\n        resolvedEnv[key] = resolveEnvVars(value);\n      }\n    }\n\n    return {\n      ...config,\n      command: resolveEnvVars(config.command),\n      args: config.args?.map(resolveEnvVars),\n      env: Object.keys(resolvedEnv).length > 0 ? resolvedEnv : undefined,\n    };\n  }\n\n  if (config.transport === \"http\") {\n    const resolvedHeaders: Record<string, string> = {};\n\n    if (config.headers) {\n      for (const [key, value] of Object.entries(config.headers)) {\n        resolvedHeaders[key] = resolveEnvVars(value);\n      }\n    }\n\n    return {\n      ...config,\n      url: resolveEnvVars(config.url),\n      headers:\n        Object.keys(resolvedHeaders).length > 0 ? resolvedHeaders : undefined,\n    };\n  }\n\n  if (config.transport === \"local\") {\n    return {\n      ...config,\n      module: resolveEnvVars(config.module),\n      toolsetExport: config.toolsetExport\n        ? resolveEnvVars(config.toolsetExport)\n        : undefined,\n    };\n  }\n\n  return config;\n}\n","import type {\n  McpServerConfigLocal,\n  McpToolDefinition,\n  McpToolWireFormat,\n  McpToolResult,\n  McpPromptDefinition,\n  McpPromptMessage,\n  McpResourceDefinition,\n  McpResourceContent,\n} from \"../types\";\nimport type { McpClient } from \"./client\";\n\ntype LocalToolset = Record<string, McpToolDefinition>;\ntype ModuleLoader = () => Promise<unknown>;\n\n// Registry for local module loaders\nconst localModuleLoaders: Map<string, ModuleLoader> = new Map();\n\n/**\n * Register a local module loader for use with MCP local transport.\n */\nexport function registerLocalModuleLoader(\n  moduleName: string,\n  loader: ModuleLoader,\n): void {\n  localModuleLoaders.set(moduleName, loader);\n}\n\nfunction isToolDefinition(value: unknown): value is McpToolDefinition {\n  if (!value || typeof value !== \"object\") return false;\n  const candidate = value as {\n    name?: unknown;\n    description?: unknown;\n    parameters?: unknown;\n  };\n  return (\n    typeof candidate.name === \"string\" &&\n    typeof candidate.description === \"string\" &&\n    typeof candidate.parameters === \"object\"\n  );\n}\n\nfunction normalizeToolset(candidate: unknown): LocalToolset | null {\n  if (!candidate || typeof candidate !== \"object\") return null;\n\n  if (isToolDefinition(candidate)) {\n    const tool = candidate;\n    return { [tool.name]: tool };\n  }\n\n  const record = candidate as Record<string, unknown>;\n  const toolset: LocalToolset = {};\n\n  for (const value of Object.values(record)) {\n    if (isToolDefinition(value)) {\n      toolset[value.name] = value;\n    }\n  }\n\n  return Object.keys(toolset).length > 0 ? toolset : null;\n}\n\nasync function loadLocalToolset(\n  config: McpServerConfigLocal,\n): Promise<LocalToolset> {\n  const loader = localModuleLoaders.get(config.module);\n  if (!loader) {\n    throw new Error(\n      `Local MCP module '${config.module}' is not registered. ` +\n        `Call registerLocalModuleLoader(\"${config.module}\", () => import(\"${config.module}\")) before connecting.`,\n    );\n  }\n\n  const moduleExports = (await loader()) as Record<string, unknown>;\n\n  if (config.toolsetExport && config.toolsetExport in moduleExports) {\n    const toolset = normalizeToolset(moduleExports[config.toolsetExport]);\n    if (toolset) return toolset;\n  }\n\n  const preferredExports = [\"webSearchTools\", \"mcpTools\", \"tools\", \"toolset\"];\n\n  for (const exportName of preferredExports) {\n    if (exportName in moduleExports) {\n      const toolset = normalizeToolset(moduleExports[exportName]);\n      if (toolset) return toolset;\n    }\n  }\n\n  const merged: LocalToolset = {};\n  for (const value of Object.values(moduleExports)) {\n    const toolset = normalizeToolset(value);\n    if (!toolset) continue;\n    for (const [name, tool] of Object.entries(toolset)) {\n      merged[name] = tool;\n    }\n  }\n\n  if (Object.keys(merged).length > 0) {\n    return merged;\n  }\n\n  throw new Error(\n    `Local MCP module '${config.module}' did not export any tools`,\n  );\n}\n\n/**\n * Create an MCP client for local (in-process) modules.\n */\nexport function createLocalClient(config: McpServerConfigLocal): McpClient {\n  let toolset: LocalToolset | null = null;\n  let isConnected = false;\n\n  const ensureToolset = async () => {\n    if (!toolset) {\n      toolset = await loadLocalToolset(config);\n    }\n    return toolset;\n  };\n\n  return {\n    config,\n\n    get connected(): boolean {\n      return isConnected;\n    },\n\n    async connect(): Promise<void> {\n      if (isConnected) return;\n      await ensureToolset();\n      isConnected = true;\n    },\n\n    async disconnect(): Promise<void> {\n      toolset = null;\n      isConnected = false;\n    },\n\n    async listTools(): Promise<McpToolWireFormat[]> {\n      const tools = await ensureToolset();\n      return Object.values(tools).map((tool) => ({\n        name: tool.name,\n        title: tool.title,\n        description: tool.description,\n        inputSchema: tool.inputSchema ?? { type: \"object\" },\n      }));\n    },\n\n    async callTool(\n      name: string,\n      args: Record<string, unknown>,\n      _options?: { timeoutMs?: number },\n    ): Promise<McpToolResult> {\n      const tools = await ensureToolset();\n      const tool = tools[name];\n      if (!tool?.execute) {\n        throw new Error(`Local tool '${name}' does not have an execute()`);\n      }\n\n      const result = await tool.execute(args);\n      const text = typeof result === \"string\" ? result : JSON.stringify(result);\n\n      return {\n        content: [{ type: \"text\", text }],\n        structuredContent: result,\n      };\n    },\n\n    async listPrompts(): Promise<McpPromptDefinition[]> {\n      return [];\n    },\n\n    async getPrompt(): Promise<McpPromptMessage[]> {\n      return [];\n    },\n\n    async listResources(): Promise<McpResourceDefinition[]> {\n      return [];\n    },\n\n    async readResource(): Promise<McpResourceContent[]> {\n      return [];\n    },\n  };\n}\n","import { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type {\n  McpServerConfig,\n  McpServerConfigStdio,\n  McpServerConfigHttp,\n  McpToolWireFormat,\n  McpToolResult,\n  McpPromptDefinition,\n  McpPromptMessage,\n  McpResourceDefinition,\n  McpResourceContent,\n} from \"../types\";\nimport type { McpClient } from \"./client\";\nimport {\n  validateCommand,\n  validateArgs,\n  sanitizeEnv,\n  validateTimeout,\n  DEFAULT_TOOL_TIMEOUT_MS,\n} from \"../security\";\n\n/**\n * Custom transport that avoids sending the mcp-protocol-version header.\n */\nclass CompatibleHTTPClientTransport extends StreamableHTTPClientTransport {\n  setProtocolVersion(version: string): void {\n    // Intentionally ignore protocol version\n  }\n}\n\n/**\n * Create an MCP client for remote servers (stdio or http).\n */\nexport function createSdkClient(\n  config: McpServerConfigStdio | McpServerConfigHttp,\n): McpClient {\n  let sdkClient: Client | null = null;\n  let isConnected = false;\n\n  return {\n    config,\n\n    get connected(): boolean {\n      return isConnected;\n    },\n\n    async connect(): Promise<void> {\n      if (isConnected && sdkClient) {\n        return;\n      }\n\n      sdkClient = new Client({\n        name: `json-render-mcp-${config.id}`,\n        version: \"1.0.0\",\n      });\n\n      let transport;\n\n      if (config.transport === \"stdio\") {\n        // Security: Validate command and args\n        const commandValidation = validateCommand(config.command);\n        if (!commandValidation.valid) {\n          throw new Error(\n            `MCP Security: ${commandValidation.error}`,\n          );\n        }\n        \n        if (config.args) {\n          const argsValidation = validateArgs(config.args);\n          if (!argsValidation.valid) {\n            throw new Error(\n              `MCP Security: ${argsValidation.error}`,\n            );\n          }\n        }\n        \n        transport = new StdioClientTransport({\n          command: config.command,\n          args: config.args,\n          env: sanitizeEnv(config.env),\n          cwd: config.cwd,\n        });\n      } else if (config.transport === \"http\") {\n        transport = new CompatibleHTTPClientTransport(new URL(config.url), {\n          requestInit: {\n            headers: config.headers,\n          },\n        });\n      } else {\n        throw new Error(\n          `Unknown transport type: ${(config as McpServerConfig).transport}`,\n        );\n      }\n\n      await sdkClient.connect(transport);\n      isConnected = true;\n    },\n\n    async disconnect(): Promise<void> {\n      if (sdkClient && isConnected) {\n        await sdkClient.close();\n        sdkClient = null;\n        isConnected = false;\n      }\n    },\n\n    async listTools(): Promise<McpToolWireFormat[]> {\n      if (!sdkClient || !isConnected) {\n        throw new Error(\"Client not connected\");\n      }\n\n      const result = await sdkClient.listTools();\n      return result.tools.map((tool) => ({\n        name: tool.name,\n        title: (tool as { title?: string }).title,\n        description: tool.description,\n        inputSchema: tool.inputSchema as McpToolWireFormat[\"inputSchema\"],\n      }));\n    },\n\n    async callTool(\n      name: string,\n      args: Record<string, unknown>,\n      options?: { timeoutMs?: number },\n    ): Promise<McpToolResult> {\n      if (!sdkClient || !isConnected) {\n        throw new Error(\"Client not connected\");\n      }\n\n      const timeoutMs = validateTimeout(options?.timeoutMs);\n      \n      // Wrap call with timeout\n      const callPromise = sdkClient.callTool({ name, arguments: args });\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => {\n          reject(new Error(`MCP tool '${name}' timed out after ${timeoutMs}ms`));\n        }, timeoutMs);\n      });\n      \n      const result = await Promise.race([callPromise, timeoutPromise]);\n\n      return {\n        content: (\n          result.content as Array<{\n            type: string;\n            text?: string;\n            data?: string;\n            mimeType?: string;\n            resource?: McpResourceContent;\n          }>\n        ).map((c) => {\n          if (c.type === \"text\") {\n            return { type: \"text\" as const, text: c.text ?? \"\" };\n          }\n          if (c.type === \"image\") {\n            return {\n              type: \"image\" as const,\n              data: c.data ?? \"\",\n              mimeType: c.mimeType ?? \"\",\n            };\n          }\n          return {\n            type: \"resource\" as const,\n            resource: c.resource as McpResourceContent,\n          };\n        }),\n        structuredContent: (result as { structuredContent?: unknown })\n          .structuredContent,\n        isError: (result as { isError?: boolean }).isError,\n      };\n    },\n\n    async listPrompts(): Promise<McpPromptDefinition[]> {\n      if (!sdkClient || !isConnected) {\n        throw new Error(\"Client not connected\");\n      }\n\n      const result = await sdkClient.listPrompts();\n      return result.prompts.map((prompt) => ({\n        name: prompt.name,\n        title: (prompt as { title?: string }).title,\n        description: prompt.description,\n        arguments: prompt.arguments?.map((arg) => ({\n          name: arg.name,\n          description: arg.description,\n          required: arg.required,\n        })),\n      }));\n    },\n\n    async getPrompt(\n      name: string,\n      args?: Record<string, string>,\n    ): Promise<McpPromptMessage[]> {\n      if (!sdkClient || !isConnected) {\n        throw new Error(\"Client not connected\");\n      }\n\n      const result = await sdkClient.getPrompt({ name, arguments: args });\n\n      return result.messages.map((msg) => {\n        const content = msg.content;\n        if (content.type === \"text\") {\n          return {\n            role: msg.role,\n            content: { type: \"text\" as const, text: content.text },\n          };\n        }\n        if (content.type === \"image\") {\n          return {\n            role: msg.role,\n            content: {\n              type: \"image\" as const,\n              data: content.data,\n              mimeType: content.mimeType,\n            },\n          };\n        }\n        return {\n          role: msg.role,\n          content: {\n            type: \"resource\" as const,\n            resource: (content as { resource: McpResourceContent }).resource,\n          },\n        };\n      });\n    },\n\n    async listResources(): Promise<McpResourceDefinition[]> {\n      if (!sdkClient || !isConnected) {\n        throw new Error(\"Client not connected\");\n      }\n\n      const result = await sdkClient.listResources();\n      return result.resources.map((resource) => ({\n        uri: resource.uri,\n        name: resource.name,\n        description: resource.description,\n        mimeType: resource.mimeType,\n      }));\n    },\n\n    async readResource(uri: string): Promise<McpResourceContent[]> {\n      if (!sdkClient || !isConnected) {\n        throw new Error(\"Client not connected\");\n      }\n\n      const result = await sdkClient.readResource({ uri });\n      return result.contents.map((content) => ({\n        uri: content.uri,\n        mimeType: content.mimeType,\n        text: (content as { text?: string }).text,\n        blob: (content as { blob?: string }).blob,\n      }));\n    },\n  };\n}\n","/**\n * MCP Security Module\n * \n * Provides security controls for MCP command execution:\n * - Command whitelist validation\n * - Path sanitization\n * - Environment variable sandboxing\n * - Timeout enforcement\n */\n\n/**\n * Allowed commands for stdio transport\n * Only these commands can be executed via MCP\n */\nexport const ALLOWED_COMMANDS = new Set([\n  // Node.js\n  \"node\",\n  \"npx\",\n  \"npm\",\n  \"pnpm\",\n  \"yarn\",\n  \"bun\",\n  \n  // Python\n  \"python\",\n  \"python3\",\n  \"pip\",\n  \"pip3\",\n  \"uv\",\n  \"uvx\",\n  \n  // Other common runtimes\n  \"deno\",\n  \"go\",\n  \"ruby\",\n  \n  // MCP-specific\n  \"mcp-server-fetch\",\n  \"mcp-server-filesystem\",\n  \"mcp-server-sqlite\",\n]);\n\n/**\n * Dangerous environment variables that should not be passed through\n */\nconst BLOCKED_ENV_VARS = new Set([\n  \"PATH\", // Prevent PATH manipulation\n  \"LD_PRELOAD\",\n  \"LD_LIBRARY_PATH\",\n  \"DYLD_INSERT_LIBRARIES\",\n  \"DYLD_LIBRARY_PATH\",\n]);\n\n/**\n * Allowed environment variables that can be passed\n */\nconst ALLOWED_ENV_VARS = new Set([\n  \"NODE_ENV\",\n  \"HOME\",\n  \"USER\",\n  \"LANG\",\n  \"LC_ALL\",\n  \"TZ\",\n  \"HTTP_PROXY\",\n  \"HTTPS_PROXY\",\n  \"NO_PROXY\",\n  // API keys are allowed (user's responsibility)\n]);\n\nexport interface SecurityValidationResult {\n  valid: boolean;\n  error?: string;\n}\n\n/**\n * Validate a command for MCP execution\n */\nexport function validateCommand(command: string): SecurityValidationResult {\n  // Extract base command (first word)\n  const parts = command.split(/\\s+/);\n  const baseCommand = parts[0] ?? \"\";\n  const pathParts = baseCommand.split(\"/\");\n  const commandName = pathParts[pathParts.length - 1] ?? baseCommand;\n  \n  if (!ALLOWED_COMMANDS.has(commandName)) {\n    return {\n      valid: false,\n      error: `Command '${commandName}' is not in the allowed commands whitelist. Allowed: ${Array.from(ALLOWED_COMMANDS).join(\", \")}`,\n    };\n  }\n  \n  // Check for shell injection patterns\n  const dangerousPatterns = [\n    /[;&|`$()]/,  // Shell metacharacters\n    /\\.\\./,       // Path traversal\n    /\\/etc\\//,    // System paths\n    /\\/proc\\//,\n    /\\/sys\\//,\n  ];\n  \n  for (const pattern of dangerousPatterns) {\n    if (pattern.test(command)) {\n      return {\n        valid: false,\n        error: `Command contains potentially dangerous pattern: ${pattern.toString()}`,\n      };\n    }\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Validate command arguments\n */\nexport function validateArgs(args: string[]): SecurityValidationResult {\n  for (const arg of args) {\n    // Check for shell injection in arguments\n    if (/[;&|`$()]/.test(arg) && !arg.startsWith(\"-\")) {\n      return {\n        valid: false,\n        error: `Argument '${arg}' contains shell metacharacters`,\n      };\n    }\n    \n    // Check for path traversal\n    if (arg.includes(\"..\") && !arg.startsWith(\"-\")) {\n      return {\n        valid: false,\n        error: `Argument '${arg}' contains path traversal`,\n      };\n    }\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Sanitize environment variables for subprocess\n * Only allows safe variables\n */\nexport function sanitizeEnv(\n  env?: Record<string, string>,\n): Record<string, string> {\n  const sanitized: Record<string, string> = {};\n  \n  if (!env) return sanitized;\n  \n  for (const [key, value] of Object.entries(env)) {\n    // Block dangerous variables\n    if (BLOCKED_ENV_VARS.has(key)) {\n      continue;\n    }\n    \n    // Allow explicitly allowed or prefixed with allowed patterns\n    if (\n      ALLOWED_ENV_VARS.has(key) ||\n      key.startsWith(\"OPENAI_\") ||\n      key.startsWith(\"ANTHROPIC_\") ||\n      key.startsWith(\"GOOGLE_\") ||\n      key.startsWith(\"GEMINI_\") ||\n      key.startsWith(\"MCP_\")\n    ) {\n      sanitized[key] = value;\n    }\n  }\n  \n  return sanitized;\n}\n\n/**\n * Default timeout for tool calls (30 seconds)\n */\nexport const DEFAULT_TOOL_TIMEOUT_MS = 30_000;\n\n/**\n * Maximum timeout for tool calls (5 minutes)\n */\nexport const MAX_TOOL_TIMEOUT_MS = 5 * 60 * 1000;\n\n/**\n * Validate timeout value\n */\nexport function validateTimeout(timeoutMs?: number): number {\n  if (timeoutMs === undefined) {\n    return DEFAULT_TOOL_TIMEOUT_MS;\n  }\n  \n  if (timeoutMs <= 0) {\n    return DEFAULT_TOOL_TIMEOUT_MS;\n  }\n  \n  return Math.min(timeoutMs, MAX_TOOL_TIMEOUT_MS);\n}\n\n/**\n * Add a command to the allowed list at runtime\n * Use with caution - should only be called during app initialization\n */\nexport function allowCommand(command: string): void {\n  ALLOWED_COMMANDS.add(command);\n}\n\n/**\n * Check if a command is allowed\n */\nexport function isCommandAllowed(command: string): boolean {\n  const commandName = command.split(\"/\").pop() ?? command;\n  return ALLOWED_COMMANDS.has(commandName);\n}\n","import type {\n  McpServerConfig,\n  McpToolWireFormat,\n  McpToolResult,\n  McpPromptDefinition,\n  McpPromptMessage,\n  McpResourceDefinition,\n  McpResourceContent,\n} from \"../types\";\nimport { resolveServerEnv } from \"../registry/env-resolver\";\nimport { createLocalClient, registerLocalModuleLoader } from \"./local-client\";\nimport { createSdkClient } from \"./sdk-client\";\n\n// Re-export\nexport { registerLocalModuleLoader };\n\n/**\n * Options for tool call execution\n */\nexport interface McpToolCallOptions {\n  /** Timeout in milliseconds (default: 30000, max: 300000) */\n  timeoutMs?: number;\n}\n\n/**\n * Wrapper around the MCP SDK client with simpler API.\n */\nexport interface McpClient {\n  readonly config: McpServerConfig;\n  readonly connected: boolean;\n\n  connect(): Promise<void>;\n  disconnect(): Promise<void>;\n\n  listTools(): Promise<McpToolWireFormat[]>;\n  callTool(\n    name: string,\n    args: Record<string, unknown>,\n    options?: McpToolCallOptions,\n  ): Promise<McpToolResult>;\n\n  listPrompts(): Promise<McpPromptDefinition[]>;\n  getPrompt(\n    name: string,\n    args?: Record<string, string>,\n  ): Promise<McpPromptMessage[]>;\n\n  listResources(): Promise<McpResourceDefinition[]>;\n  readResource(uri: string): Promise<McpResourceContent[]>;\n}\n\n/**\n * Create an MCP client for a server configuration.\n */\nexport function createMcpClient(config: McpServerConfig): McpClient {\n  const resolvedConfig = resolveServerEnv(config);\n\n  if (resolvedConfig.transport === \"local\") {\n    return createLocalClient(resolvedConfig);\n  }\n\n  return createSdkClient(resolvedConfig);\n}\n","import type { McpRegistry } from \"../registry\";\nimport type { McpConnectionConfig, McpServerState } from \"../types\";\nimport { createMcpClient, type McpClient } from \"./client\";\n\nconst DEFAULT_CONNECT_TIMEOUT_MS = 30000;\nconst DEFAULT_REFRESH_TIMEOUT_MS = 20000;\nconst DEFAULT_HEALTH_CHECK_TIMEOUT_MS = 15000;\n\nfunction withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutMessage: string,\n): Promise<T> {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  return new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      reject(new Error(timeoutMessage));\n    }, timeoutMs);\n\n    promise.then(\n      (value) => {\n        if (timeoutId) clearTimeout(timeoutId);\n        resolve(value);\n      },\n      (error) => {\n        if (timeoutId) clearTimeout(timeoutId);\n        reject(error);\n      },\n    );\n  });\n}\n\n// =============================================================================\n// Connection Manager\n// =============================================================================\n\n/**\n * Connection manager for MCP clients.\n *\n * Features:\n * - Persistent connections with health checks\n * - Lazy initialization (connect on first use)\n * - Automatic reconnection\n * - listChanged notification handling\n */\nexport interface McpConnectionManager {\n  /**\n   * Get or create a client for a server.\n   * Connects lazily on first use.\n   */\n  getClient(serverId: string): Promise<McpClient>;\n\n  /**\n   * Check if a client is connected.\n   */\n  isConnected(serverId: string): boolean;\n\n  /**\n   * Disconnect a specific server.\n   */\n  disconnect(serverId: string): Promise<void>;\n\n  /**\n   * Disconnect all servers.\n   */\n  disconnectAll(): Promise<void>;\n\n  /**\n   * Refresh tools for a server (after listChanged notification).\n   */\n  refreshTools(serverId: string): Promise<void>;\n\n  /**\n   * Start health check loop.\n   */\n  startHealthChecks(): void;\n\n  /**\n   * Stop health check loop.\n   */\n  stopHealthChecks(): void;\n}\n\n/**\n * Create a connection manager.\n */\nexport function createConnectionManager(\n  registry: McpRegistry,\n  config?: Partial<McpConnectionConfig>,\n): McpConnectionManager {\n  const connectionConfig: McpConnectionConfig = {\n    strategy: config?.strategy ?? registry.connectionConfig.strategy,\n    healthCheckInterval:\n      config?.healthCheckInterval ??\n      registry.connectionConfig.healthCheckInterval,\n    maxIdleTime: config?.maxIdleTime ?? registry.connectionConfig.maxIdleTime,\n    reconnectAttempts:\n      config?.reconnectAttempts ?? registry.connectionConfig.reconnectAttempts,\n  };\n\n  const clients = new Map<string, McpClient>();\n  const pendingConnections = new Map<string, Promise<McpClient>>();\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n  let healthCheckInFlight = false;\n\n  // Helper to update server state\n  function updateState(\n    serverId: string,\n    status: McpServerState[\"status\"],\n    error?: string,\n  ): void {\n    try {\n      registry.setStatus(serverId, status, error);\n    } catch {\n      // Server might have been removed\n    }\n  }\n\n  // Helper to refresh tools from a connected client\n  async function refreshToolsForClient(\n    serverId: string,\n    client: McpClient,\n  ): Promise<void> {\n    try {\n      const tools = await withTimeout(\n        client.listTools(),\n        DEFAULT_REFRESH_TIMEOUT_MS,\n        `Refreshing tools timed out for ${serverId}`,\n      );\n      registry.setTools(serverId, tools);\n\n      // Also refresh prompts and resources\n      try {\n        const prompts = await withTimeout(\n          client.listPrompts(),\n          DEFAULT_REFRESH_TIMEOUT_MS,\n          `Refreshing prompts timed out for ${serverId}`,\n        );\n        registry.setPrompts(serverId, prompts);\n      } catch {\n        // Prompts might not be supported\n      }\n\n      try {\n        const resources = await withTimeout(\n          client.listResources(),\n          DEFAULT_REFRESH_TIMEOUT_MS,\n          `Refreshing resources timed out for ${serverId}`,\n        );\n        registry.setResources(serverId, resources);\n      } catch {\n        // Resources might not be supported\n      }\n    } catch (error) {\n      console.error(`Error refreshing tools for ${serverId}:`, error);\n    }\n  }\n\n  const manager: McpConnectionManager = {\n    async getClient(serverId: string): Promise<McpClient> {\n      // Check if already connected\n      const existing = clients.get(serverId);\n      if (existing?.connected) {\n        return existing;\n      }\n\n      const pending = pendingConnections.get(serverId);\n      if (pending) {\n        return pending;\n      }\n\n      // Get server config\n      const serverConfig = registry.getServer(serverId);\n      if (!serverConfig) {\n        throw new Error(`Server ${serverId} not found in registry`);\n      }\n\n      if (serverConfig.enabled === false) {\n        throw new Error(`Server ${serverId} is disabled`);\n      }\n\n      const connectPromise = (async (): Promise<McpClient> => {\n        const reusedClient = clients.get(serverId);\n        const client = reusedClient ?? createMcpClient(serverConfig);\n        clients.set(serverId, client);\n\n        // Update state\n        updateState(serverId, \"connecting\");\n\n        try {\n          // Connect\n          await withTimeout(\n            client.connect(),\n            serverConfig.timeout ?? DEFAULT_CONNECT_TIMEOUT_MS,\n            `Connection timed out for ${serverId}`,\n          );\n          updateState(serverId, \"connected\");\n\n          // Refresh tools after connection\n          await refreshToolsForClient(serverId, client);\n\n          return client;\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : String(error);\n          updateState(serverId, \"error\", errorMessage);\n          clients.delete(serverId);\n          throw error;\n        }\n      })();\n\n      pendingConnections.set(serverId, connectPromise);\n      try {\n        return await connectPromise;\n      } finally {\n        pendingConnections.delete(serverId);\n      }\n    },\n\n    isConnected(serverId: string): boolean {\n      const client = clients.get(serverId);\n      return client?.connected ?? false;\n    },\n\n    async disconnect(serverId: string): Promise<void> {\n      const client = clients.get(serverId);\n      pendingConnections.delete(serverId);\n      if (client) {\n        try {\n          await client.disconnect();\n        } catch (error) {\n          console.error(`Error disconnecting ${serverId}:`, error);\n        }\n        clients.delete(serverId);\n        updateState(serverId, \"disconnected\");\n      }\n    },\n\n    async disconnectAll(): Promise<void> {\n      const disconnectPromises: Promise<void>[] = [];\n      const serverIds = Array.from(clients.keys());\n\n      for (let i = 0; i < serverIds.length; i++) {\n        const serverId = serverIds[i];\n        if (serverId) {\n          disconnectPromises.push(manager.disconnect(serverId));\n        }\n      }\n\n      await Promise.all(disconnectPromises);\n    },\n\n    async refreshTools(serverId: string): Promise<void> {\n      const client = clients.get(serverId);\n      if (client?.connected) {\n        await refreshToolsForClient(serverId, client);\n      }\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) {\n        return;\n      }\n\n      const interval = connectionConfig.healthCheckInterval ?? 60000;\n\n      healthCheckInterval = setInterval(() => {\n        if (healthCheckInFlight) return;\n        healthCheckInFlight = true;\n\n        void (async () => {\n          const entries = Array.from(clients.entries());\n          for (let i = 0; i < entries.length; i++) {\n            const entry = entries[i];\n            if (!entry) continue;\n            const [serverId, client] = entry;\n            const serverConfig = registry.getServer(serverId);\n            const timeoutMs =\n              serverConfig?.timeout ?? DEFAULT_HEALTH_CHECK_TIMEOUT_MS;\n\n            if (!client.connected) {\n              // Try to reconnect\n              try {\n                await withTimeout(\n                  client.connect(),\n                  timeoutMs,\n                  `Health-check reconnect timed out for ${serverId}`,\n                );\n                updateState(serverId, \"connected\");\n                await refreshToolsForClient(serverId, client);\n              } catch (error) {\n                const errorMessage =\n                  error instanceof Error ? error.message : String(error);\n                updateState(serverId, \"error\", errorMessage);\n              }\n            } else {\n              // Verify connection is still alive by listing tools\n              try {\n                await withTimeout(\n                  client.listTools(),\n                  timeoutMs,\n                  `Health-check listTools timed out for ${serverId}`,\n                );\n              } catch {\n                updateState(serverId, \"disconnected\");\n                // Will reconnect on next health check or getClient call\n              }\n            }\n          }\n        })()\n          .catch((error) => {\n            console.error(\"[MCP] Health check loop failed:\", error);\n          })\n          .finally(() => {\n            healthCheckInFlight = false;\n          });\n      }, interval);\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n\n  // Listen for registry events\n  registry.on((event) => {\n    if (event.type === \"server:removed\") {\n      // Disconnect removed servers\n      manager.disconnect(event.serverId).catch(() => {\n        // Ignore errors\n      });\n    }\n  });\n\n  return manager;\n}\n"],"mappings":"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","names":[]}