{"version":3,"sources":["../src/index.ts","../src/schema.ts","../src/define.ts","../src/registry.ts","../src/registry/config-parser.ts","../src/registry/env-resolver.ts","../src/tool-selection/constants.ts","../src/tool-selection/keyword-extractor.ts","../src/tool-selection/domain-inferrer.ts","../src/selection.ts","../src/security.ts","../src/catalog/registry.ts"],"sourcesContent":["// =============================================================================\n// @onegenui/mcp - Model Context Protocol integration\n// =============================================================================\n\n// Types\nexport type {\n  // Core types\n  McpDomain,\n  JsonSchema,\n  // Tool types\n  McpToolDefinition,\n  McpToolWireFormat,\n  McpToolResult,\n  McpToolResultContent,\n  // Prompt types\n  McpPromptDefinition,\n  McpPromptArgument,\n  McpPromptMessage,\n  // Resource types\n  McpResourceDefinition,\n  McpResourceContent,\n  // Server types\n  McpTransportType,\n  McpServerConfig,\n  McpServerConfigBase,\n  McpServerConfigStdio,\n  McpServerConfigHttp,\n  McpServerMetadata,\n  McpServerState,\n  // Config types\n  McpSelectionConfig,\n  McpConnectionConfig,\n  McpServerConfigInput,\n  McpConfigFile,\n  // Registry types\n  McpRegistryEvent,\n  McpRegistryEventHandler,\n  McpRegistryOptions,\n  // Selection types\n  ToolSelectionContext,\n  ToolSelectionOptions,\n  ScoredTool,\n} from \"./types\";\n\n// Schema utilities\nexport {\n  zodToMcpSchema,\n  emptyInputSchema,\n  mergeSchemas,\n  validateMcpSchema,\n  extractSchemaMetadata,\n  type ZodToMcpSchemaOptions,\n} from \"./schema\";\n\n// Define helpers\nexport {\n  defineMcpTool,\n  defineMcpPrompt,\n  defineMcpServer,\n  toolFromWireFormat,\n  extractToolMetadata,\n  type DefineMcpToolConfig,\n  type DefineMcpPromptConfig,\n  type DefineMcpServerConfig,\n  type InferToolParams,\n} from \"./define\";\n\n// Registry\nexport { createMcpRegistry, type McpRegistry } from \"./registry\";\nexport { resolveEnvVars, resolveServerEnv } from \"./registry/env-resolver\";\n\n// Selection\nexport {\n  selectToolsForPrompt,\n  getAllTools,\n  getToolsByDomain,\n} from \"./selection\";\n\n// Security\nexport {\n  ALLOWED_COMMANDS,\n  validateCommand,\n  validateArgs,\n  sanitizeEnv,\n  validateTimeout,\n  allowCommand,\n  isCommandAllowed,\n  DEFAULT_TOOL_TIMEOUT_MS,\n  MAX_TOOL_TIMEOUT_MS,\n  type SecurityValidationResult,\n} from \"./security\";\n\n// Re-export client and integration from subpaths\n// Users can also import directly from '@onegenui/mcp/client'\n// and '@onegenui/mcp/integration'\n\n// Catalog\nexport type {\n  McpAppCatalogEntry,\n  McpAppCategory,\n  McpAppOAuthConfig,\n} from \"./catalog/types\";\n\nexport {\n  MCP_APP_CATALOG,\n  getAllCatalogEntries,\n  getCatalogEntry,\n  getCatalogByCategory,\n  searchCatalog,\n} from \"./catalog/registry\";\n","import type { z } from \"zod\";\nimport { zodToJsonSchema as zodToJsonSchemaLib } from \"zod-to-json-schema\";\nimport type { JsonSchema } from \"./types\";\n\n/**\n * Options for Zod to JSON Schema conversion.\n */\nexport interface ZodToMcpSchemaOptions {\n  /**\n   * Target JSON Schema version.\n   * @default \"jsonSchema7\"\n   */\n  target?: \"jsonSchema7\" | \"jsonSchema2019-09\" | \"openApi3\";\n  /**\n   * Enable support for recursive schemas using $ref.\n   * @default false\n   */\n  useReferences?: boolean;\n  /**\n   * Name for the schema (used in $ref paths).\n   */\n  name?: string;\n}\n\n/**\n * Convert a Zod schema to JSON Schema format for MCP inputSchema.\n *\n * Uses zod-to-json-schema internally with MCP-optimized defaults.\n *\n * @example\n * ```ts\n * import { z } from 'zod';\n * import { zodToMcpSchema } from '@onegenui/mcp';\n *\n * const params = z.object({\n *   location: z.string().describe('City name'),\n *   units: z.enum(['celsius', 'fahrenheit']).default('celsius'),\n * });\n *\n * const jsonSchema = zodToMcpSchema(params);\n * // {\n * //   type: 'object',\n * //   properties: {\n * //     location: { type: 'string', description: 'City name' },\n * //     units: { type: 'string', enum: ['celsius', 'fahrenheit'], default: 'celsius' }\n * //   },\n * //   required: ['location']\n * // }\n * ```\n */\nexport function zodToMcpSchema(\n  schema: z.ZodTypeAny,\n  options: ZodToMcpSchemaOptions = {},\n): JsonSchema {\n  const { target = \"jsonSchema7\", useReferences = false, name } = options;\n\n  // Cast to any to work around Zod v4 type differences with zod-to-json-schema\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result = zodToJsonSchemaLib(schema as any, {\n    target,\n    $refStrategy: useReferences ? \"root\" : \"none\",\n    name,\n  });\n\n  // Clean up the result for MCP format\n  // Remove $schema and definitions if not using references\n  if (!useReferences) {\n    const cleaned = { ...result } as JsonSchema;\n    delete cleaned.$schema;\n    delete cleaned.$id;\n\n    // If there's a definitions wrapper, unwrap it\n    if (name && cleaned.definitions?.[name]) {\n      const inner = cleaned.definitions[name] as JsonSchema;\n      delete cleaned.definitions;\n      return { ...cleaned, ...inner };\n    }\n\n    // CRITICAL: Gemini requires type: \"object\" for function parameters\n    // Ensure the schema always has type: \"object\"\n    if (!cleaned.type) {\n      cleaned.type = \"object\";\n    }\n    if (cleaned.type !== \"object\") {\n      // Wrap non-object schemas in an object\n      return {\n        type: \"object\",\n        properties: { value: cleaned },\n        required: [\"value\"],\n      };\n    }\n\n    return cleaned;\n  }\n\n  // For referenced schemas, also ensure type: \"object\"\n  const refResult = result as JsonSchema;\n  if (!refResult.type) {\n    refResult.type = \"object\";\n  }\n\n  return refResult;\n}\n\n/**\n * Create an empty object schema for tools with no parameters.\n * This follows the MCP specification recommendation.\n */\nexport function emptyInputSchema(): JsonSchema {\n  return {\n    type: \"object\",\n    properties: {},\n    additionalProperties: false,\n  };\n}\n\n/**\n * Merge multiple JSON schemas into a single object schema.\n * Useful for combining base schemas with extensions.\n */\nexport function mergeSchemas(...schemas: JsonSchema[]): JsonSchema {\n  const merged: JsonSchema = {\n    type: \"object\",\n    properties: {},\n    required: [],\n  };\n\n  for (const schema of schemas) {\n    if (schema.properties) {\n      merged.properties = { ...merged.properties, ...schema.properties };\n    }\n    if (schema.required && Array.isArray(schema.required)) {\n      const existing = merged.required as string[];\n      const combined = [...existing, ...schema.required];\n      // Deduplicate using object keys\n      const unique: Record<string, true> = {};\n      for (const item of combined) {\n        unique[item] = true;\n      }\n      merged.required = Object.keys(unique);\n    }\n  }\n\n  // Clean up empty required array\n  if ((merged.required as string[]).length === 0) {\n    delete merged.required;\n  }\n\n  return merged;\n}\n\n/**\n * Validate that a JSON Schema is compatible with MCP requirements.\n * Returns validation errors if any.\n */\nexport function validateMcpSchema(schema: JsonSchema): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // MCP requires object type for inputSchema\n  if (schema.type !== \"object\") {\n    errors.push(\n      `inputSchema must have type 'object', got '${schema.type ?? \"undefined\"}'`,\n    );\n  }\n\n  // Check for unsupported features\n  if (schema.$ref && !schema.$defs && !schema.definitions) {\n    errors.push(\"$ref used without $defs or definitions\");\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Extract metadata from a Zod schema for tool selection.\n * Looks for .describe() calls and extracts keywords.\n */\nexport function extractSchemaMetadata(schema: z.ZodTypeAny): {\n  description?: string;\n  keywords: string[];\n} {\n  const keywords: string[] = [];\n  let description: string | undefined;\n\n  // Try to get description from the schema\n  try {\n    // Access the _def property which contains schema metadata\n    const def = (schema as unknown as { _def?: { description?: string } })._def;\n    if (def?.description) {\n      description = def.description;\n      // Extract keywords from description\n      const words = description.toLowerCase().split(/\\s+/);\n      for (const word of words) {\n        if (word.length > 3 && !stopWords[word]) {\n          keywords.push(word);\n        }\n      }\n    }\n  } catch {\n    // Ignore errors from accessing internal properties\n  }\n\n  return { description, keywords };\n}\n\n// Common stop words to filter from keyword extraction\nconst STOP_WORDS = [\n  \"the\",\n  \"a\",\n  \"an\",\n  \"and\",\n  \"or\",\n  \"but\",\n  \"in\",\n  \"on\",\n  \"at\",\n  \"to\",\n  \"for\",\n  \"of\",\n  \"with\",\n  \"by\",\n  \"from\",\n  \"as\",\n  \"is\",\n  \"was\",\n  \"are\",\n  \"were\",\n  \"been\",\n  \"be\",\n  \"have\",\n  \"has\",\n  \"had\",\n  \"do\",\n  \"does\",\n  \"did\",\n  \"will\",\n  \"would\",\n  \"could\",\n  \"should\",\n  \"may\",\n  \"might\",\n  \"must\",\n  \"shall\",\n  \"can\",\n  \"this\",\n  \"that\",\n  \"these\",\n  \"those\",\n  \"it\",\n  \"its\",\n] as const;\n\nconst stopWords: Record<string, true> = {};\nfor (let i = 0; i < STOP_WORDS.length; i++) {\n  const word = STOP_WORDS[i];\n  if (word) {\n    stopWords[word] = true;\n  }\n}\n","import { z } from \"zod\";\nimport type {\n  McpToolDefinition,\n  McpPromptDefinition,\n  McpPromptArgument,\n  McpServerConfig,\n  McpServerConfigStdio,\n  McpServerConfigHttp,\n  McpDomain,\n  JsonSchema,\n} from \"./types\";\nimport { zodToMcpSchema } from \"./schema\";\n\n// =============================================================================\n// Tool Definition\n// =============================================================================\n\n/**\n * Configuration for defining an MCP tool.\n */\nexport interface DefineMcpToolConfig<\n  TParams extends z.ZodObject<z.ZodRawShape>,\n> {\n  /** Unique tool name (should be snake_case) */\n  name: string;\n  /** Human-readable title */\n  title?: string;\n  /** Tool description for LLM (be specific and detailed) */\n  description: string;\n  /** Zod schema for parameters */\n  parameters: TParams;\n  /** Semantic domain for tool selection */\n  domain?: McpDomain;\n  /** Tags for keyword-based selection */\n  tags?: string[];\n  /** Local execution function (optional) */\n  execute?: (params: z.infer<TParams>) => Promise<unknown>;\n}\n\n/**\n * Define an MCP tool with full type inference.\n *\n * Uses Zod for type-safe parameter definition, which is automatically\n * converted to JSON Schema for the MCP wire format.\n *\n * @example\n * ```ts\n * import { z } from 'zod';\n * import { defineMcpTool } from '@onegenui/mcp';\n *\n * const weatherTool = defineMcpTool({\n *   name: 'get_weather',\n *   description: 'Get the current weather for a location',\n *   parameters: z.object({\n *     location: z.string().describe('City name or coordinates'),\n *     units: z.enum(['celsius', 'fahrenheit']).default('celsius'),\n *   }),\n *   domain: 'data',\n *   tags: ['weather', 'api', 'forecast'],\n *   execute: async ({ location, units }) => {\n *     // Implementation\n *     return { temperature: 22, units };\n *   },\n * });\n * ```\n */\nexport function defineMcpTool<TParams extends z.ZodObject<z.ZodRawShape>>(\n  config: DefineMcpToolConfig<TParams>,\n): McpToolDefinition<TParams> {\n  const { name, title, description, parameters, domain, tags, execute } =\n    config;\n\n  // Convert Zod schema to JSON Schema for MCP wire format\n  const inputSchema = zodToMcpSchema(parameters);\n\n  return {\n    name,\n    title,\n    description,\n    parameters,\n    inputSchema,\n    domain,\n    tags,\n    execute,\n  };\n}\n\n/**\n * Infer the parameter type from a tool definition.\n */\nexport type InferToolParams<T extends McpToolDefinition> = z.infer<\n  T[\"parameters\"]\n>;\n\n// =============================================================================\n// Prompt Definition\n// =============================================================================\n\n/**\n * Configuration for defining an MCP prompt.\n */\nexport interface DefineMcpPromptConfig {\n  /** Unique prompt name */\n  name: string;\n  /** Human-readable title */\n  title?: string;\n  /** Prompt description */\n  description?: string;\n  /** Arguments the prompt accepts */\n  arguments?: McpPromptArgument[];\n}\n\n/**\n * Define an MCP prompt template.\n *\n * @example\n * ```ts\n * const reviewPrompt = defineMcpPrompt({\n *   name: 'code_review',\n *   title: 'Code Review',\n *   description: 'Review code for best practices and potential issues',\n *   arguments: [\n *     { name: 'code', description: 'The code to review', required: true },\n *     { name: 'language', description: 'Programming language' },\n *   ],\n * });\n * ```\n */\nexport function defineMcpPrompt(\n  config: DefineMcpPromptConfig,\n): McpPromptDefinition {\n  return {\n    name: config.name,\n    title: config.title,\n    description: config.description,\n    arguments: config.arguments,\n  };\n}\n\n// =============================================================================\n// Server Definition\n// =============================================================================\n\n/**\n * Base configuration for defining an MCP server.\n */\ninterface DefineMcpServerConfigBase {\n  /** Unique server identifier */\n  id: string;\n  /** Human-readable server name */\n  name?: string;\n  /** Semantic domain for the server's tools */\n  domain?: McpDomain;\n  /** Tags for keyword-based selection */\n  tags?: string[];\n  /** Whether this server is enabled */\n  enabled?: boolean;\n  /** Request timeout in milliseconds */\n  timeout?: number;\n}\n\n/**\n * Stdio server configuration.\n */\ninterface DefineMcpServerConfigStdio extends DefineMcpServerConfigBase {\n  transport: \"stdio\";\n  /** Command to spawn */\n  command: string;\n  /** Command arguments */\n  args?: string[];\n  /** Environment variables */\n  env?: Record<string, string>;\n  /** Working directory */\n  cwd?: string;\n}\n\n/**\n * HTTP server configuration.\n */\ninterface DefineMcpServerConfigHttp extends DefineMcpServerConfigBase {\n  transport: \"http\";\n  /** Server URL */\n  url: string;\n  /** HTTP headers */\n  headers?: Record<string, string>;\n}\n\n/**\n * Union type for server configuration.\n */\nexport type DefineMcpServerConfig =\n  | DefineMcpServerConfigStdio\n  | DefineMcpServerConfigHttp;\n\n/**\n * Define an MCP server configuration.\n *\n * @example\n * ```ts\n * // Stdio server (spawns a process)\n * const filesystemServer = defineMcpServer({\n *   id: 'filesystem',\n *   name: 'Filesystem Access',\n *   transport: 'stdio',\n *   command: 'npx',\n *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/data'],\n *   domain: 'files',\n *   tags: ['read', 'write', 'directory'],\n * });\n *\n * // HTTP server\n * const apiServer = defineMcpServer({\n *   id: 'api',\n *   name: 'API Gateway',\n *   transport: 'http',\n *   url: 'http://localhost:3001/mcp',\n *   domain: 'data',\n * });\n * ```\n */\nexport function defineMcpServer(\n  config: DefineMcpServerConfig,\n): McpServerConfig {\n  if (config.transport === \"stdio\") {\n    const stdioConfig: McpServerConfigStdio = {\n      id: config.id,\n      name: config.name,\n      transport: \"stdio\",\n      command: config.command,\n      args: config.args,\n      env: config.env,\n      cwd: config.cwd,\n      domain: config.domain,\n      tags: config.tags,\n      enabled: config.enabled ?? true,\n      timeout: config.timeout,\n    };\n    return stdioConfig;\n  }\n\n  const httpConfig: McpServerConfigHttp = {\n    id: config.id,\n    name: config.name,\n    transport: \"http\",\n    url: config.url,\n    headers: config.headers,\n    domain: config.domain,\n    tags: config.tags,\n    enabled: config.enabled ?? true,\n    timeout: config.timeout,\n  };\n  return httpConfig;\n}\n\n// =============================================================================\n// Utility Functions\n// =============================================================================\n\n/**\n * Create a tool definition from MCP wire format.\n * Useful when loading tools from a remote MCP server.\n */\nexport function toolFromWireFormat(\n  wireFormat: {\n    name: string;\n    title?: string;\n    description?: string;\n    inputSchema: JsonSchema;\n    outputSchema?: JsonSchema;\n  },\n  options?: {\n    domain?: McpDomain;\n    tags?: string[];\n  },\n): McpToolDefinition {\n  // Create a passthrough Zod schema since we don't have the original\n  const parameters = z.object({}).passthrough();\n\n  return {\n    name: wireFormat.name,\n    title: wireFormat.title,\n    description: wireFormat.description ?? \"\",\n    parameters,\n    inputSchema: wireFormat.inputSchema,\n    outputSchema: wireFormat.outputSchema,\n    domain: options?.domain,\n    tags: options?.tags,\n  };\n}\n\n/**\n * Extract tool metadata for selection optimization.\n */\nexport function extractToolMetadata(tool: McpToolDefinition): {\n  name: string;\n  description: string;\n  domain?: McpDomain;\n  tags: string[];\n  keywords: string[];\n} {\n  // Extract keywords from name and description\n  const keywords: string[] = [];\n\n  // Add name parts (split by underscore)\n  const nameParts = tool.name.split(\"_\");\n  for (const part of nameParts) {\n    if (part.length > 2) {\n      keywords.push(part.toLowerCase());\n    }\n  }\n\n  // Add words from description\n  if (tool.description) {\n    const words = tool.description.toLowerCase().split(/\\s+/);\n    for (const word of words) {\n      // Clean up word\n      const cleaned = word.replace(/[^a-z0-9]/g, \"\");\n      if (cleaned.length > 3) {\n        keywords.push(cleaned);\n      }\n    }\n  }\n\n  // Add tags\n  if (tool.tags) {\n    for (const tag of tool.tags) {\n      keywords.push(tag.toLowerCase());\n    }\n  }\n\n  // Deduplicate\n  const uniqueKeywords: Record<string, true> = {};\n  for (const kw of keywords) {\n    uniqueKeywords[kw] = true;\n  }\n\n  return {\n    name: tool.name,\n    description: tool.description,\n    domain: tool.domain,\n    tags: tool.tags ?? [],\n    keywords: Object.keys(uniqueKeywords),\n  };\n}\n","import { readFileSync, existsSync, watch as fsWatch } from \"fs\";\nimport { createLogger } from \"@onegenui/utils\";\nimport type {\n  McpServerConfig,\n  McpServerState,\n  McpConfigFile,\n  McpConnectionConfig,\n  McpSelectionConfig,\n  McpRegistryEvent,\n  McpRegistryEventHandler,\n  McpRegistryOptions,\n  McpToolWireFormat,\n  McpPromptDefinition,\n  McpResourceDefinition,\n} from \"./types\";\n\nimport {\n  parseServerConfig,\n  createServerState,\n  computeMetadata,\n} from \"./registry/config-parser\";\n\n// Re-exports now come from registry/ directory\n// Use: import { resolveEnvVars, resolveServerEnv } from '@onegenui/mcp/registry'\n\nconst mcpLogger = createLogger({ prefix: \"mcp:registry\" });\n\n/**\n * MCP Registry manages server configurations and their states.\n */\nexport interface McpRegistry {\n  add(server: McpServerConfig): void;\n  remove(serverId: string): void;\n  update(serverId: string, config: Partial<McpServerConfig>): void;\n\n  getServer(id: string): McpServerConfig | undefined;\n  getServerState(id: string): McpServerState | undefined;\n  listServers(): McpServerConfig[];\n  listServerStates(): Map<string, McpServerState>;\n  hasServer(id: string): boolean;\n\n  setTools(serverId: string, tools: McpToolWireFormat[]): void;\n  setPrompts(serverId: string, prompts: McpPromptDefinition[]): void;\n  setResources(serverId: string, resources: McpResourceDefinition[]): void;\n\n  setStatus(\n    serverId: string,\n    status: McpServerState[\"status\"],\n    error?: string,\n  ): void;\n\n  loadFromConfig(path: string): void;\n  watchConfig(path: string): void;\n  stopWatching(): void;\n\n  on(handler: McpRegistryEventHandler): () => void;\n  emit(event: McpRegistryEvent): void;\n\n  readonly connectionConfig: McpConnectionConfig;\n  readonly selectionConfig: McpSelectionConfig;\n}\n\n/**\n * Create an MCP registry instance.\n */\nexport function createMcpRegistry(\n  options: McpRegistryOptions = {},\n): McpRegistry {\n  const {\n    configPath,\n    watchConfig = false,\n    connection = {},\n    selection = {},\n  } = options;\n\n  const servers = new Map<string, McpServerConfig>();\n  const states = new Map<string, McpServerState>();\n  const handlers: McpRegistryEventHandler[] = [];\n  let watchController: { close: () => void } | null = null;\n\n  const connectionConfig: McpConnectionConfig = {\n    strategy: connection.strategy ?? \"persistent\",\n    healthCheckInterval: connection.healthCheckInterval ?? 60000,\n    maxIdleTime: connection.maxIdleTime ?? 300000,\n    reconnectAttempts: connection.reconnectAttempts ?? 3,\n  };\n\n  const selectionConfig: McpSelectionConfig = {\n    maxToolsPerRequest: selection.maxToolsPerRequest ?? 10,\n    strategy: selection.strategy ?? \"keyword\",\n    priorityDomains: selection.priorityDomains,\n  };\n\n  function emit(event: McpRegistryEvent): void {\n    for (const handler of handlers) {\n      try {\n        handler(event);\n      } catch (error) {\n        mcpLogger.error(\"Error in registry event handler:\", error);\n      }\n    }\n  }\n\n  const registry: McpRegistry = {\n    connectionConfig,\n    selectionConfig,\n\n    add(server: McpServerConfig): void {\n      if (servers.has(server.id)) {\n        throw new Error(`Server ${server.id} already exists`);\n      }\n\n      servers.set(server.id, server);\n      states.set(server.id, createServerState(server));\n\n      emit({ type: \"server:added\", serverId: server.id, config: server });\n    },\n\n    remove(serverId: string): void {\n      if (!servers.has(serverId)) {\n        return;\n      }\n\n      servers.delete(serverId);\n      states.delete(serverId);\n\n      emit({ type: \"server:removed\", serverId });\n    },\n\n    update(serverId: string, updates: Partial<McpServerConfig>): void {\n      const existing = servers.get(serverId);\n      if (!existing) {\n        throw new Error(`Server ${serverId} does not exist`);\n      }\n\n      const updated = {\n        ...existing,\n        ...updates,\n        id: serverId,\n      } as McpServerConfig;\n      servers.set(serverId, updated);\n\n      const state = states.get(serverId);\n      if (state) {\n        state.config = updated;\n      }\n\n      emit({ type: \"server:updated\", serverId, config: updated });\n    },\n\n    getServer(id: string): McpServerConfig | undefined {\n      return servers.get(id);\n    },\n\n    getServerState(id: string): McpServerState | undefined {\n      return states.get(id);\n    },\n\n    listServers(): McpServerConfig[] {\n      return Array.from(servers.values());\n    },\n\n    listServerStates(): Map<string, McpServerState> {\n      return new Map(states);\n    },\n\n    hasServer(id: string): boolean {\n      return servers.has(id);\n    },\n\n    setTools(serverId: string, tools: McpToolWireFormat[]): void {\n      const state = states.get(serverId);\n      if (!state) {\n        throw new Error(`Server ${serverId} does not exist`);\n      }\n\n      state.tools = tools;\n      state.metadata = computeMetadata(\n        tools,\n        state.config.domain,\n        state.config.tags,\n      );\n\n      emit({ type: \"tools:changed\", serverId });\n    },\n\n    setPrompts(serverId: string, prompts: McpPromptDefinition[]): void {\n      const state = states.get(serverId);\n      if (!state) {\n        throw new Error(`Server ${serverId} does not exist`);\n      }\n\n      state.prompts = prompts;\n    },\n\n    setResources(serverId: string, resources: McpResourceDefinition[]): void {\n      const state = states.get(serverId);\n      if (!state) {\n        throw new Error(`Server ${serverId} does not exist`);\n      }\n\n      state.resources = resources;\n    },\n\n    setStatus(\n      serverId: string,\n      status: McpServerState[\"status\"],\n      error?: string,\n    ): void {\n      const state = states.get(serverId);\n      if (!state) {\n        throw new Error(`Server ${serverId} does not exist`);\n      }\n\n      const previousStatus = state.status;\n      state.status = status;\n      state.error = error;\n\n      if (status === \"connected\" && previousStatus !== \"connected\") {\n        emit({ type: \"server:connected\", serverId });\n      } else if (status === \"disconnected\" && previousStatus === \"connected\") {\n        emit({ type: \"server:disconnected\", serverId });\n      } else if (status === \"error\") {\n        emit({\n          type: \"server:error\",\n          serverId,\n          error: error ?? \"Unknown error\",\n        });\n      }\n    },\n\n    loadFromConfig(path: string): void {\n      if (!existsSync(path)) {\n        throw new Error(`Config file not found: ${path}`);\n      }\n\n      const content = readFileSync(path, \"utf-8\");\n      const config = JSON.parse(content) as McpConfigFile;\n\n      if (!config.servers || typeof config.servers !== \"object\") {\n        throw new Error(\"Config file must have a 'servers' object\");\n      }\n\n      const currentIds = new Set(servers.keys());\n      const newIds = new Set<string>();\n\n      for (const [id, input] of Object.entries(config.servers)) {\n        newIds.add(id);\n\n        try {\n          const serverConfig = parseServerConfig(id, input);\n\n          if (currentIds.has(id)) {\n            registry.update(id, serverConfig);\n          } else {\n            registry.add(serverConfig);\n          }\n        } catch (error) {\n          mcpLogger.error(`Error processing server ${id}:`, error);\n        }\n      }\n\n      const currentIdsArray = Array.from(currentIds);\n      for (let i = 0; i < currentIdsArray.length; i++) {\n        const id = currentIdsArray[i];\n        if (id && !newIds.has(id)) {\n          registry.remove(id);\n        }\n      }\n\n      if (config.selection) {\n        Object.assign(selectionConfig, config.selection);\n      }\n\n      if (config.connection) {\n        Object.assign(connectionConfig, config.connection);\n      }\n    },\n\n    watchConfig(path: string): void {\n      registry.stopWatching();\n\n      if (!existsSync(path)) {\n        mcpLogger.warn(\n          `Config file not found, watching will start when created: ${path}`,\n        );\n      }\n\n      const watcher = fsWatch(path, { persistent: false }, (eventType) => {\n        if (eventType === \"change\") {\n          mcpLogger.log(`MCP config changed, reloading: ${path}`);\n          try {\n            registry.loadFromConfig(path);\n          } catch (error) {\n            mcpLogger.error(\"Error reloading config:\", error);\n          }\n        }\n      });\n\n      watchController = { close: () => watcher.close() };\n    },\n\n    stopWatching(): void {\n      if (watchController) {\n        watchController.close();\n        watchController = null;\n      }\n    },\n\n    on(handler: McpRegistryEventHandler): () => void {\n      handlers.push(handler);\n\n      return () => {\n        const index = handlers.indexOf(handler);\n        if (index !== -1) {\n          handlers.splice(index, 1);\n        }\n      };\n    },\n\n    emit,\n  };\n\n  if (configPath && existsSync(configPath)) {\n    registry.loadFromConfig(configPath);\n\n    if (watchConfig) {\n      registry.watchConfig(configPath);\n    }\n  }\n\n  return registry;\n}\n","import type {\n  McpServerConfig,\n  McpServerConfigInput,\n  McpServerState,\n  McpToolWireFormat,\n  McpDomain,\n  McpServerMetadata,\n} from \"../types\";\n\n/**\n * Parse config input to full server config\n */\nexport function parseServerConfig(\n  id: string,\n  input: McpServerConfigInput,\n): McpServerConfig {\n  const base = {\n    id,\n    name: input.name,\n    domain: input.domain,\n    tags: input.tags,\n    enabled: input.enabled ?? true,\n    timeout: input.timeout,\n  };\n\n  if (input.transport === \"stdio\") {\n    if (!input.command) {\n      throw new Error(`Server ${id}: stdio transport requires 'command'`);\n    }\n    return {\n      ...base,\n      transport: \"stdio\",\n      command: input.command,\n      args: input.args,\n      env: input.env,\n      cwd: input.cwd,\n    };\n  }\n\n  if (input.transport === \"local\") {\n    if (!input.module) {\n      throw new Error(`Server ${id}: local transport requires 'module'`);\n    }\n    return {\n      ...base,\n      transport: \"local\",\n      module: input.module,\n      toolsetExport: input.toolsetExport,\n    };\n  }\n\n  if (input.transport === \"http\") {\n    if (!input.url) {\n      throw new Error(`Server ${id}: http transport requires 'url'`);\n    }\n    return {\n      ...base,\n      transport: \"http\",\n      url: input.url,\n      headers: input.headers,\n    };\n  }\n\n  throw new Error(`Server ${id}: unknown transport '${input.transport}'`);\n}\n\n/**\n * Create initial server state\n */\nexport function createServerState(config: McpServerConfig): McpServerState {\n  return {\n    config,\n    status: \"disconnected\",\n  };\n}\n\n/**\n * Compute metadata from tools\n */\nexport function computeMetadata(\n  tools: McpToolWireFormat[],\n  serverDomain?: McpDomain,\n  serverTags?: string[],\n): McpServerMetadata {\n  const domains: Record<string, true> = {};\n  const tags: Record<string, true> = {};\n  const toolNames: string[] = [];\n\n  if (serverDomain) {\n    domains[serverDomain] = true;\n  }\n\n  if (serverTags) {\n    for (const tag of serverTags) {\n      tags[tag] = true;\n    }\n  }\n\n  for (const tool of tools) {\n    toolNames.push(tool.name);\n  }\n\n  return {\n    toolCount: tools.length,\n    domains: Object.keys(domains) as McpDomain[],\n    tags: Object.keys(tags),\n    toolNames,\n    lastRefreshed: new Date(),\n  };\n}\n","import type { McpServerConfig } from \"../types\";\n\n/**\n * Resolve environment variables in a string.\n * Supports ${VAR_NAME} syntax.\n */\nexport function resolveEnvVars(value: string): string {\n  return value.replace(/\\$\\{([^}]+)\\}/g, (_, varName) => {\n    return process.env[varName] ?? \"\";\n  });\n}\n\n/**\n * Resolve environment variables in server config.\n */\nexport function resolveServerEnv(config: McpServerConfig): McpServerConfig {\n  if (config.transport === \"stdio\") {\n    const resolvedEnv: Record<string, string> = {};\n\n    if (config.env) {\n      for (const [key, value] of Object.entries(config.env)) {\n        resolvedEnv[key] = resolveEnvVars(value);\n      }\n    }\n\n    return {\n      ...config,\n      command: resolveEnvVars(config.command),\n      args: config.args?.map(resolveEnvVars),\n      env: Object.keys(resolvedEnv).length > 0 ? resolvedEnv : undefined,\n    };\n  }\n\n  if (config.transport === \"http\") {\n    const resolvedHeaders: Record<string, string> = {};\n\n    if (config.headers) {\n      for (const [key, value] of Object.entries(config.headers)) {\n        resolvedHeaders[key] = resolveEnvVars(value);\n      }\n    }\n\n    return {\n      ...config,\n      url: resolveEnvVars(config.url),\n      headers:\n        Object.keys(resolvedHeaders).length > 0 ? resolvedHeaders : undefined,\n    };\n  }\n\n  if (config.transport === \"local\") {\n    return {\n      ...config,\n      module: resolveEnvVars(config.module),\n      toolsetExport: config.toolsetExport\n        ? resolveEnvVars(config.toolsetExport)\n        : undefined,\n    };\n  }\n\n  return config;\n}\n","/**\n * Tool selection constants and stop words\n */\n\n/**\n * Common stop words to filter out during keyword extraction\n */\nexport const STOP_WORDS: Record<string, true> = {\n  the: true,\n  a: true,\n  an: true,\n  and: true,\n  or: true,\n  but: true,\n  in: true,\n  on: true,\n  at: true,\n  to: true,\n  for: true,\n  of: true,\n  with: true,\n  by: true,\n  from: true,\n  as: true,\n  is: true,\n  was: true,\n  are: true,\n  were: true,\n  been: true,\n  be: true,\n  have: true,\n  has: true,\n  had: true,\n  do: true,\n  does: true,\n  did: true,\n  will: true,\n  would: true,\n  could: true,\n  should: true,\n  may: true,\n  might: true,\n  must: true,\n  shall: true,\n  can: true,\n  this: true,\n  that: true,\n  these: true,\n  those: true,\n  it: true,\n  its: true,\n  get: true,\n  set: true,\n  use: true,\n  want: true,\n  need: true,\n  like: true,\n  help: true,\n  please: true,\n  how: true,\n  what: true,\n  when: true,\n  where: true,\n  why: true,\n  who: true,\n};\n","/**\n * Keyword extraction utilities\n */\n\nimport { STOP_WORDS } from \"./constants\";\n\n/**\n * Extract keywords from text for matching\n * Filters out stop words and short words\n */\nexport function extractKeywords(text: string): string[] {\n  const words = text.toLowerCase().split(/\\s+/);\n  const keywords: string[] = [];\n\n  for (const word of words) {\n    const cleaned = word.replace(/[^a-z0-9]/g, \"\");\n    if (cleaned.length > 2 && !STOP_WORDS[cleaned]) {\n      keywords.push(cleaned);\n    }\n  }\n\n  return keywords;\n}\n\n/**\n * Extract keywords from multiple sources\n */\nexport function extractKeywordsFromSources(\n  sources: (string | undefined)[],\n): string[] {\n  const keywords: string[] = [];\n\n  for (const source of sources) {\n    if (source) {\n      keywords.push(...extractKeywords(source));\n    }\n  }\n\n  return keywords;\n}\n","/**\n * Domain inference from keywords\n */\n\nimport type { McpDomain } from \"../types\";\n\n/**\n * Domain keyword mappings for inference\n */\nexport const DOMAIN_KEYWORDS: Record<McpDomain, string[]> = {\n  files: [\n    \"file\",\n    \"folder\",\n    \"directory\",\n    \"read\",\n    \"write\",\n    \"create\",\n    \"delete\",\n    \"move\",\n    \"copy\",\n    \"path\",\n    \"filesystem\",\n    \"storage\",\n    \"upload\",\n    \"download\",\n  ],\n  vcs: [\n    \"git\",\n    \"github\",\n    \"commit\",\n    \"branch\",\n    \"merge\",\n    \"pull\",\n    \"push\",\n    \"repository\",\n    \"repo\",\n    \"clone\",\n    \"checkout\",\n    \"diff\",\n    \"pr\",\n    \"issue\",\n    \"code\",\n    \"review\",\n  ],\n  web: [\n    \"http\",\n    \"https\",\n    \"url\",\n    \"fetch\",\n    \"request\",\n    \"response\",\n    \"api\",\n    \"rest\",\n    \"graphql\",\n    \"scrape\",\n    \"crawl\",\n    \"browser\",\n    \"page\",\n    \"website\",\n  ],\n  data: [\n    \"database\",\n    \"sql\",\n    \"query\",\n    \"table\",\n    \"record\",\n    \"insert\",\n    \"update\",\n    \"select\",\n    \"mongodb\",\n    \"postgres\",\n    \"mysql\",\n    \"redis\",\n    \"cache\",\n    \"data\",\n    \"json\",\n  ],\n  ops: [\n    \"deploy\",\n    \"build\",\n    \"run\",\n    \"execute\",\n    \"command\",\n    \"shell\",\n    \"terminal\",\n    \"process\",\n    \"service\",\n    \"docker\",\n    \"kubernetes\",\n    \"container\",\n    \"server\",\n    \"monitor\",\n  ],\n  comm: [\n    \"email\",\n    \"message\",\n    \"send\",\n    \"notify\",\n    \"slack\",\n    \"discord\",\n    \"chat\",\n    \"sms\",\n    \"notification\",\n    \"alert\",\n    \"webhook\",\n  ],\n  finance: [\n    \"payment\",\n    \"invoice\",\n    \"billing\",\n    \"stripe\",\n    \"transaction\",\n    \"money\",\n    \"currency\",\n    \"price\",\n    \"subscription\",\n    \"charge\",\n  ],\n  security: [\n    \"auth\",\n    \"login\",\n    \"password\",\n    \"token\",\n    \"secret\",\n    \"encrypt\",\n    \"decrypt\",\n    \"permission\",\n    \"access\",\n    \"oauth\",\n    \"jwt\",\n    \"credential\",\n  ],\n  ai: [\n    \"ai\",\n    \"ml\",\n    \"model\",\n    \"predict\",\n    \"generate\",\n    \"embed\",\n    \"vector\",\n    \"llm\",\n    \"openai\",\n    \"anthropic\",\n    \"gemini\",\n    \"inference\",\n  ],\n  travel: [\n    \"flight\",\n    \"flights\",\n    \"airline\",\n    \"airport\",\n    \"booking\",\n    \"travel\",\n    \"trip\",\n    \"destination\",\n    \"departure\",\n    \"arrival\",\n    \"hotel\",\n    \"hotels\",\n    \"accommodation\",\n    \"reservation\",\n    \"itinerary\",\n    \"vacation\",\n    \"roundtrip\",\n    \"oneway\",\n    \"layover\",\n    \"stopover\",\n    \"passenger\",\n    \"baggage\",\n    \"luggage\",\n    \"boarding\",\n    \"ticket\",\n    \"fare\",\n    \"kiwi\",\n  ],\n  custom: [],\n};\n\n/**\n * Infer relevant domains from prompt keywords\n * Returns domains sorted by relevance score\n */\nexport function inferDomains(keywords: string[]): McpDomain[] {\n  const domainScores: Record<McpDomain, number> = {\n    files: 0,\n    vcs: 0,\n    web: 0,\n    data: 0,\n    ops: 0,\n    comm: 0,\n    finance: 0,\n    security: 0,\n    ai: 0,\n    travel: 0,\n    custom: 0,\n  };\n\n  for (const keyword of keywords) {\n    for (const domain of Object.keys(DOMAIN_KEYWORDS) as McpDomain[]) {\n      const domainKeywords = DOMAIN_KEYWORDS[domain];\n      for (const dk of domainKeywords) {\n        if (keyword.includes(dk) || dk.includes(keyword)) {\n          domainScores[domain]++;\n        }\n      }\n    }\n  }\n\n  // Return domains with score > 0, sorted by score descending\n  return Object.entries(domainScores)\n    .filter(([, score]) => score > 0)\n    .sort((a, b) => b[1] - a[1])\n    .map(([domain]) => domain as McpDomain);\n}\n\n/**\n * Check if a domain matches any of the inferred domains\n */\nexport function domainMatches(\n  domain: McpDomain | undefined,\n  inferredDomains: McpDomain[],\n): { matches: boolean; rank: number } {\n  if (!domain) return { matches: false, rank: -1 };\n\n  const rank = inferredDomains.indexOf(domain);\n  return { matches: rank >= 0, rank };\n}\n","/**\n * Tool Selection for MCP Servers\n *\n * This module provides intelligent tool selection using keyword and domain matching.\n * It uses modular components from ./tool-selection/ for each concern:\n * - keyword-extractor: Extract keywords from text\n * - domain-inferrer: Infer domains from keywords\n * - tool-scorer: Score tools against context\n */\n\nimport type {\n  McpToolWireFormat,\n  McpDomain,\n  McpServerState,\n  ToolSelectionContext,\n  ToolSelectionOptions,\n  ScoredTool,\n} from \"./types\";\n\n// Import modular components\nimport { extractKeywords } from \"./tool-selection/keyword-extractor\";\nimport {\n  inferDomains,\n  DOMAIN_KEYWORDS,\n} from \"./tool-selection/domain-inferrer\";\nimport { STOP_WORDS } from \"./tool-selection/constants\";\n\n// Re-export for convenience\nexport { extractKeywords, inferDomains, DOMAIN_KEYWORDS, STOP_WORDS };\n\n// =============================================================================\n// Tool Scoring\n// =============================================================================\n\n/**\n * Score a tool against the selection context.\n */\nfunction scoreTool(\n  tool: McpToolWireFormat,\n  serverId: string,\n  serverDomain: McpDomain | undefined,\n  serverTags: string[] | undefined,\n  promptKeywords: string[],\n  inferredDomains: McpDomain[],\n  context: ToolSelectionContext,\n): ScoredTool {\n  let score = 0;\n  const matchReasons: string[] = [];\n\n  // Extract tool keywords\n  const toolKeywords: string[] = [];\n\n  // From name\n  const nameParts = tool.name.split(\"_\");\n  for (const part of nameParts) {\n    toolKeywords.push(part.toLowerCase());\n  }\n\n  // From description\n  if (tool.description) {\n    const descKeywords = extractKeywords(tool.description);\n    for (const kw of descKeywords) {\n      toolKeywords.push(kw);\n    }\n  }\n\n  // From title\n  if (tool.title) {\n    const titleKeywords = extractKeywords(tool.title);\n    for (const kw of titleKeywords) {\n      toolKeywords.push(kw);\n    }\n  }\n\n  // 1. Keyword matching (max 0.5)\n  let keywordMatches = 0;\n  for (const promptKw of promptKeywords) {\n    for (const toolKw of toolKeywords) {\n      if (promptKw === toolKw) {\n        keywordMatches++;\n        matchReasons.push(`exact: ${promptKw}`);\n      } else if (promptKw.includes(toolKw) || toolKw.includes(promptKw)) {\n        keywordMatches += 0.5;\n        matchReasons.push(`partial: ${promptKw}~${toolKw}`);\n      }\n    }\n  }\n  score += Math.min(keywordMatches * 0.1, 0.5);\n\n  // 2. Domain matching (max 0.3)\n  const effectiveDomain = serverDomain;\n  if (effectiveDomain && inferredDomains.includes(effectiveDomain)) {\n    const domainIndex = inferredDomains.indexOf(effectiveDomain);\n    // Higher score for first inferred domain\n    score += 0.3 - domainIndex * 0.05;\n    matchReasons.push(`domain: ${effectiveDomain}`);\n  }\n\n  // 3. Tag matching (max 0.2)\n  if (serverTags && serverTags.length > 0) {\n    let tagMatches = 0;\n    for (const tag of serverTags) {\n      for (const promptKw of promptKeywords) {\n        if (tag.toLowerCase() === promptKw) {\n          tagMatches++;\n          matchReasons.push(`tag: ${tag}`);\n        }\n      }\n    }\n    score += Math.min(tagMatches * 0.1, 0.2);\n  }\n\n  // 4. Include domain boost (if specified in context)\n  if (context.includeDomains && effectiveDomain) {\n    if (context.includeDomains.includes(effectiveDomain)) {\n      score += 0.2;\n      matchReasons.push(`include: ${effectiveDomain}`);\n    }\n  }\n\n  // 5. Exclude domain penalty\n  if (context.excludeDomains && effectiveDomain) {\n    if (context.excludeDomains.includes(effectiveDomain)) {\n      score = 0;\n      matchReasons.length = 0;\n      matchReasons.push(`excluded: ${effectiveDomain}`);\n    }\n  }\n\n  return {\n    tool,\n    serverId,\n    score: Math.min(score, 1), // Cap at 1\n    matchReasons,\n  };\n}\n\n// =============================================================================\n// Main Selection Function\n// =============================================================================\n\n/**\n * Select relevant tools for a prompt using keyword matching.\n *\n * This implements a Copilot-style tool selection strategy:\n * 1. Extract keywords from the prompt\n * 2. Infer relevant domains from keywords\n * 3. Score each tool based on keyword, domain, and tag matching\n * 4. Return top N tools sorted by score\n *\n * @example\n * ```ts\n * const selectedTools = selectToolsForPrompt(\n *   serverStates,\n *   {\n *     prompt: 'Read the package.json file and update the version',\n *     currentFile: 'package.json',\n *   },\n *   { maxTools: 10 }\n * );\n * ```\n */\nexport function selectToolsForPrompt(\n  serverStates: Map<string, McpServerState> | Record<string, McpServerState>,\n  context: ToolSelectionContext,\n  options: ToolSelectionOptions = {},\n): ScoredTool[] {\n  const {\n    maxTools = 10,\n    minScore = 0.1,\n    includePriorityDomains = true,\n  } = options;\n\n  // Extract keywords from prompt\n  const promptKeywords = extractKeywords(context.prompt);\n\n  // Add keywords from current file if available\n  if (context.currentFile) {\n    const fileKeywords = extractKeywords(context.currentFile);\n    for (const kw of fileKeywords) {\n      promptKeywords.push(kw);\n    }\n  }\n\n  // Add keywords from user intent if available\n  if (context.userIntent) {\n    const intentKeywords = extractKeywords(context.userIntent);\n    for (const kw of intentKeywords) {\n      promptKeywords.push(kw);\n    }\n  }\n\n  // Infer domains from keywords\n  const inferredDomains = inferDomains(promptKeywords);\n\n  // Score all tools\n  const scoredTools: ScoredTool[] = [];\n\n  // Handle both Map and Record\n  const entries =\n    serverStates instanceof Map\n      ? Array.from(serverStates.entries())\n      : Object.entries(serverStates);\n\n  for (const [serverId, state] of entries) {\n    // Skip disabled or disconnected servers\n    if (state.config.enabled === false) continue;\n    if (state.status === \"error\") continue;\n\n    // Skip if no cached tools\n    if (!state.tools || state.tools.length === 0) continue;\n\n    for (const tool of state.tools) {\n      const scored = scoreTool(\n        tool,\n        serverId,\n        state.config.domain,\n        state.config.tags,\n        promptKeywords,\n        inferredDomains,\n        context,\n      );\n\n      if (scored.score >= minScore) {\n        scoredTools.push(scored);\n      }\n    }\n  }\n\n  // Sort by score descending\n  scoredTools.sort((a, b) => b.score - a.score);\n\n  // Return top N\n  return scoredTools.slice(0, maxTools);\n}\n\n/**\n * Get all tools from server states (no filtering).\n */\nexport function getAllTools(\n  serverStates: Map<string, McpServerState> | Record<string, McpServerState>,\n): { tool: McpToolWireFormat; serverId: string }[] {\n  const tools: { tool: McpToolWireFormat; serverId: string }[] = [];\n\n  const entries =\n    serverStates instanceof Map\n      ? Array.from(serverStates.entries())\n      : Object.entries(serverStates);\n\n  for (const [serverId, state] of entries) {\n    if (state.config.enabled === false) continue;\n    if (!state.tools) continue;\n\n    for (const tool of state.tools) {\n      tools.push({ tool, serverId });\n    }\n  }\n\n  return tools;\n}\n\n/**\n * Get tools by domain.\n */\nexport function getToolsByDomain(\n  serverStates: Map<string, McpServerState> | Record<string, McpServerState>,\n  domain: McpDomain,\n): { tool: McpToolWireFormat; serverId: string }[] {\n  const tools: { tool: McpToolWireFormat; serverId: string }[] = [];\n\n  const entries =\n    serverStates instanceof Map\n      ? Array.from(serverStates.entries())\n      : Object.entries(serverStates);\n\n  for (const [serverId, state] of entries) {\n    if (state.config.enabled === false) continue;\n    if (state.config.domain !== domain) continue;\n    if (!state.tools) continue;\n\n    for (const tool of state.tools) {\n      tools.push({ tool, serverId });\n    }\n  }\n\n  return tools;\n}\n","/**\n * MCP Security Module\n * \n * Provides security controls for MCP command execution:\n * - Command whitelist validation\n * - Path sanitization\n * - Environment variable sandboxing\n * - Timeout enforcement\n */\n\n/**\n * Allowed commands for stdio transport\n * Only these commands can be executed via MCP\n */\nexport const ALLOWED_COMMANDS = new Set([\n  // Node.js\n  \"node\",\n  \"npx\",\n  \"npm\",\n  \"pnpm\",\n  \"yarn\",\n  \"bun\",\n  \n  // Python\n  \"python\",\n  \"python3\",\n  \"pip\",\n  \"pip3\",\n  \"uv\",\n  \"uvx\",\n  \n  // Other common runtimes\n  \"deno\",\n  \"go\",\n  \"ruby\",\n  \n  // MCP-specific\n  \"mcp-server-fetch\",\n  \"mcp-server-filesystem\",\n  \"mcp-server-sqlite\",\n]);\n\n/**\n * Dangerous environment variables that should not be passed through\n */\nconst BLOCKED_ENV_VARS = new Set([\n  \"PATH\", // Prevent PATH manipulation\n  \"LD_PRELOAD\",\n  \"LD_LIBRARY_PATH\",\n  \"DYLD_INSERT_LIBRARIES\",\n  \"DYLD_LIBRARY_PATH\",\n]);\n\n/**\n * Allowed environment variables that can be passed\n */\nconst ALLOWED_ENV_VARS = new Set([\n  \"NODE_ENV\",\n  \"HOME\",\n  \"USER\",\n  \"LANG\",\n  \"LC_ALL\",\n  \"TZ\",\n  \"HTTP_PROXY\",\n  \"HTTPS_PROXY\",\n  \"NO_PROXY\",\n  // API keys are allowed (user's responsibility)\n]);\n\nexport interface SecurityValidationResult {\n  valid: boolean;\n  error?: string;\n}\n\n/**\n * Validate a command for MCP execution\n */\nexport function validateCommand(command: string): SecurityValidationResult {\n  // Extract base command (first word)\n  const parts = command.split(/\\s+/);\n  const baseCommand = parts[0] ?? \"\";\n  const pathParts = baseCommand.split(\"/\");\n  const commandName = pathParts[pathParts.length - 1] ?? baseCommand;\n  \n  if (!ALLOWED_COMMANDS.has(commandName)) {\n    return {\n      valid: false,\n      error: `Command '${commandName}' is not in the allowed commands whitelist. Allowed: ${Array.from(ALLOWED_COMMANDS).join(\", \")}`,\n    };\n  }\n  \n  // Check for shell injection patterns\n  const dangerousPatterns = [\n    /[;&|`$()]/,  // Shell metacharacters\n    /\\.\\./,       // Path traversal\n    /\\/etc\\//,    // System paths\n    /\\/proc\\//,\n    /\\/sys\\//,\n  ];\n  \n  for (const pattern of dangerousPatterns) {\n    if (pattern.test(command)) {\n      return {\n        valid: false,\n        error: `Command contains potentially dangerous pattern: ${pattern.toString()}`,\n      };\n    }\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Validate command arguments\n */\nexport function validateArgs(args: string[]): SecurityValidationResult {\n  for (const arg of args) {\n    // Check for shell injection in arguments\n    if (/[;&|`$()]/.test(arg) && !arg.startsWith(\"-\")) {\n      return {\n        valid: false,\n        error: `Argument '${arg}' contains shell metacharacters`,\n      };\n    }\n    \n    // Check for path traversal\n    if (arg.includes(\"..\") && !arg.startsWith(\"-\")) {\n      return {\n        valid: false,\n        error: `Argument '${arg}' contains path traversal`,\n      };\n    }\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Sanitize environment variables for subprocess\n * Only allows safe variables\n */\nexport function sanitizeEnv(\n  env?: Record<string, string>,\n): Record<string, string> {\n  const sanitized: Record<string, string> = {};\n  \n  if (!env) return sanitized;\n  \n  for (const [key, value] of Object.entries(env)) {\n    // Block dangerous variables\n    if (BLOCKED_ENV_VARS.has(key)) {\n      continue;\n    }\n    \n    // Allow explicitly allowed or prefixed with allowed patterns\n    if (\n      ALLOWED_ENV_VARS.has(key) ||\n      key.startsWith(\"OPENAI_\") ||\n      key.startsWith(\"ANTHROPIC_\") ||\n      key.startsWith(\"GOOGLE_\") ||\n      key.startsWith(\"GEMINI_\") ||\n      key.startsWith(\"MCP_\")\n    ) {\n      sanitized[key] = value;\n    }\n  }\n  \n  return sanitized;\n}\n\n/**\n * Default timeout for tool calls (30 seconds)\n */\nexport const DEFAULT_TOOL_TIMEOUT_MS = 30_000;\n\n/**\n * Maximum timeout for tool calls (5 minutes)\n */\nexport const MAX_TOOL_TIMEOUT_MS = 5 * 60 * 1000;\n\n/**\n * Validate timeout value\n */\nexport function validateTimeout(timeoutMs?: number): number {\n  if (timeoutMs === undefined) {\n    return DEFAULT_TOOL_TIMEOUT_MS;\n  }\n  \n  if (timeoutMs <= 0) {\n    return DEFAULT_TOOL_TIMEOUT_MS;\n  }\n  \n  return Math.min(timeoutMs, MAX_TOOL_TIMEOUT_MS);\n}\n\n/**\n * Add a command to the allowed list at runtime\n * Use with caution - should only be called during app initialization\n */\nexport function allowCommand(command: string): void {\n  ALLOWED_COMMANDS.add(command);\n}\n\n/**\n * Check if a command is allowed\n */\nexport function isCommandAllowed(command: string): boolean {\n  const commandName = command.split(\"/\").pop() ?? command;\n  return ALLOWED_COMMANDS.has(commandName);\n}\n","/**\n * MCP App Catalog Registry\n *\n * Static registry of pre-configured MCP server templates\n * that users can browse and install from the marketplace.\n */\nimport type { McpAppCatalogEntry } from \"./types\";\n\n// =============================================================================\n// Catalog entries\n// =============================================================================\n\nexport const MCP_APP_CATALOG: readonly McpAppCatalogEntry[] = [\n  {\n    id: \"github\",\n    name: \"GitHub\",\n    description:\n      \"Access repositories, issues, pull requests, and code search. Manage your GitHub workflow directly through AI.\",\n    icon: \"github\",\n    category: \"development\",\n    transport: \"stdio\",\n    configTemplate: {\n      transport: \"stdio\",\n      name: \"GitHub\",\n      command: \"npx\",\n      args: [\"-y\", \"@modelcontextprotocol/server-github\"],\n      env: { GITHUB_PERSONAL_ACCESS_TOKEN: \"\" },\n      domain: \"vcs\",\n      tags: [\"git\", \"github\", \"code\", \"repository\", \"issues\", \"pull-requests\"],\n    },\n    requiredEnvVars: [\"GITHUB_PERSONAL_ACCESS_TOKEN\"],\n    oauthConfig: {\n      authUrl: \"https://github.com/login/oauth/authorize\",\n      tokenUrl: \"https://github.com/login/oauth/access_token\",\n      scopes: [\"repo\", \"read:org\"],\n    },\n  },\n  {\n    id: \"filesystem\",\n    name: \"Filesystem\",\n    description:\n      \"Read, write, and manage files on your local filesystem. Navigate directories, search for files, and edit content.\",\n    icon: \"folder\",\n    category: \"filesystem\",\n    transport: \"stdio\",\n    configTemplate: {\n      transport: \"stdio\",\n      name: \"Filesystem\",\n      command: \"npx\",\n      args: [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/tmp\"],\n      domain: \"files\",\n      tags: [\"files\", \"filesystem\", \"directory\", \"read\", \"write\"],\n    },\n    requiredEnvVars: [],\n  },\n  {\n    id: \"sqlite\",\n    name: \"SQLite\",\n    description:\n      \"Query and manage SQLite databases. Run SQL queries, inspect schemas, and perform data analysis on local databases.\",\n    icon: \"database\",\n    category: \"data\",\n    transport: \"stdio\",\n    configTemplate: {\n      transport: \"stdio\",\n      name: \"SQLite\",\n      command: \"npx\",\n      args: [\"-y\", \"@modelcontextprotocol/server-sqlite\", \"\"],\n      domain: \"data\",\n      tags: [\"database\", \"sql\", \"sqlite\", \"query\", \"data\"],\n    },\n    requiredEnvVars: [],\n  },\n  {\n    id: \"brave-search\",\n    name: \"Brave Search\",\n    description:\n      \"Search the web using the Brave Search API. Get real-time search results, news, and web content for research.\",\n    icon: \"search\",\n    category: \"productivity\",\n    transport: \"stdio\",\n    configTemplate: {\n      transport: \"stdio\",\n      name: \"Brave Search\",\n      command: \"npx\",\n      args: [\"-y\", \"@modelcontextprotocol/server-brave-search\"],\n      env: { BRAVE_API_KEY: \"\" },\n      domain: \"web\",\n      tags: [\"search\", \"web\", \"brave\", \"internet\", \"research\"],\n    },\n    requiredEnvVars: [\"BRAVE_API_KEY\"],\n  },\n  {\n    id: \"fetch\",\n    name: \"Fetch\",\n    description:\n      \"Fetch and extract content from any URL. Retrieve web pages, APIs, and online resources for analysis.\",\n    icon: \"globe\",\n    category: \"productivity\",\n    transport: \"stdio\",\n    configTemplate: {\n      transport: \"stdio\",\n      name: \"Fetch\",\n      command: \"npx\",\n      args: [\"-y\", \"@modelcontextprotocol/server-fetch\"],\n      domain: \"web\",\n      tags: [\"fetch\", \"http\", \"url\", \"web\", \"api\", \"scrape\"],\n    },\n    requiredEnvVars: [],\n  },\n] as const;\n\n// =============================================================================\n// Catalog query helpers\n// =============================================================================\n\n/**\n * Get all catalog entries.\n */\nexport function getAllCatalogEntries(): readonly McpAppCatalogEntry[] {\n  return MCP_APP_CATALOG;\n}\n\n/**\n * Get a single catalog entry by ID.\n */\nexport function getCatalogEntry(id: string): McpAppCatalogEntry | undefined {\n  return MCP_APP_CATALOG.find((entry) => entry.id === id);\n}\n\n/**\n * Filter catalog entries by category.\n */\nexport function getCatalogByCategory(\n  category: McpAppCatalogEntry[\"category\"],\n): readonly McpAppCatalogEntry[] {\n  return MCP_APP_CATALOG.filter((entry) => entry.category === category);\n}\n\n/**\n * Search catalog entries by name or description.\n */\nexport function searchCatalog(query: string): readonly McpAppCatalogEntry[] {\n  const lower = query.toLowerCase();\n  return MCP_APP_CATALOG.filter(\n    (entry) =>\n      entry.name.toLowerCase().includes(lower) ||\n      entry.description.toLowerCase().includes(lower),\n  );\n}\n"],"mappings":"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","names":["zodToJsonSchemaLib","fsWatch","STOP_WORDS","STOP_WORDS"]}